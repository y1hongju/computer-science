# Ch 04. Transaction

## 1. Transaction

### 1-1. 트랜잭션이란?

데이터베이스에서 트랜잭션이란 데이터베이스 관리 시스템에서 데이터의 무결성을 유지하기 위해 사용되는 개념으로 하나 이상의 데이터베이스 작업을 논리적인 단위로 묶어서 실행하는 것을 의미한다. 작업이 모두 성공적으로 완료되어 전부 반영되거나(commit) 그렇지 않다면 전부 반영되지 않는(rollback) 원칙이 적용된다. 트랜잭션의 일반적인 동작 과정은 다음과 같다.

1. Start: 트랜잭션이 시작된다.
2. Execute: 하나 이상의 데이터베이스 쿼리나 업데이트가 실행된다.
3. Check: 트랜잭션의 모든 작업이 성공적으로 완료되었는지 검사한다.
4. Commit/Rollback: 모든 작업이 성공되었다면 트랜잭션을 commit 하고, 그렇지 않다면 rollback 한다.

### 1-2. 트랜잭션의 특성

트랜잭션은 다음과 같은 네 가지의 주요 특성으로 정의된다.

#### 1-2-1. 원자성: Atomicity

트랜잭션 내의 모든 작업은 하나의 트랜잭션 단위로 처리된다. 모든 작업이 성공적으로 완료되거나 그렇지 않은 경우 두 가지로 나뉘며 작업이 하나라도 실패한 경우 트랜잭션 전체의 실패로 간주되어 트랜잭션 이전의 상태로 rollback 된다.

#### 1-2-2. 일관성: Consistency

트랜잭션의 실행 전후로 데이터베이스의 상태가 일관성 있게 유지된다. 이는 데이터베이스가 정확하고 모순이 없는 상태를 의미하며 트랜잭션이 실행되기 전 데이터베이스가 어떠한 규칙이나 제약조건을 충족하는 상태였다면, 트랜잭션 실행 이후에도 동일한 규칙이나 제약조건을 만족하는 상태를 유지함을 의미한다. 트랜잭션이 성공적으로 완료되면 데이터베이스는 하나의 일관된 상태에서 새로운 일관된 상태로 변경된다.

#### 1-2-3. 독립성: Isolation

동시에 실행되는 다수의 트랜잭션이 서로의 중간 상태를 볼 수 없도록 격리되는 특성이다. 이는 각 트랜잭션이 다른 트랜잭션의 중간 실행과 상관 없이 독립적으로 실행됨을 보장한다. 독립성은 그 정도에 따라 여러 수준으로 나뉘며 성능과 데이터 일관성 유지를 애플리케이션의 요구 사항과 특성에 맞게 적절하게 트레이드오프 해야 한다. 낮은 격리 수준은 보다 높은 동시성을 제공하지만 데이터 무결성에 문제가 발생할 위험이 증가하고, 높은 격리 수준은 보다 높은 정도의 데이터 무결성이 보장되지만 전체적인 데이터베이스 성능 저하와 교착상태(deadlock)이 발생할 가능성이 증가하는 문제가 있다. 다음은 SQL 표준에서 정의하는 네 가지 격리 수준이다.

| Isolation Level  | Dirty Read | Non-Repeatable Read | Phantom Read |
| ---------------- | ---------- | ------------------- | ------------ |
| READ UNCOMMITTED | 👀         | 👀                  | 👀           |
| READ COMMITTED   | ✅         | 👀                  | 👀           |
| REPEATABLE READ  | ✅         | ✅                  | 👀           |
| SERIALIZABLE     | ✅         | ✅                  | ✅           |

##### 1-2-3-1. READ UNCOMMIT

SQL 표준 격리 수준 중 가장 낮은 격리 수준으로, 어떤 트랜잭션이 아직 커밋되지 않은 다른 트랜잭션의 데이터를 읽을 수 있도록 허용하는 특성을 지닌다. 이로 인해 다른 트랜잭션이 rollback 되어 데이터 일관성이 깨지는 dirty read 문제가 발생할 수 있다.

##### 1-2-3-2. READ COMMITTED

어떤 트랜잭션이 다른 트랜잭션의 데이터를 읽을 때, 커밋이 확정된 트랜잭션의 데이터만을 읽는 특성을 가진 격리 수준이다. 이 격리 수준은 dirty read 문제는 방지하지만, 트랜잭션 내에서 데이터 조회와 같은 동일한 쿼리를 두 번 이상 실행했을 때 다른 결과값이 적용되어 논리적 일관성이 유지되지 않는 non-repetable reads 문제가 발생할 수 있다.

##### 1-2-3-3. REPETABLE READ

어떤 트랜잭션 내에서 처음 읽은 데이터를 반복해서 읽을 때, 항상 같은 값을 보장하도록 하는 특성을 지닌다. 이는 non-repetable reads 문제는 해결하지만, 반복된 조회등의 쿼리에서 다른 트랜잭션이 새로운 데이터를 삽입하고 커밋한 경우 이전 쿼리의 결과값에는 없던 새로운 데이터(phantom data)가 발생하여 각 쿼리의 결과 집합이 서로 동일하지 않은 문제가 발생할 수 있다.

##### 1-2-3-4. SERIALIZABLE

SQL 표준 격리 수준 중 가장 높은 격리 수준으로, 각 트랜잭션이 마치 순차적으로 실행되는 것과 같은 특성을 지닌다. 이 수준으로 모든 종류의 데이터 조회(읽기) 문제를 방지할 수 있지만, 동시성 처리 성능이 저하되는 문제가 발생할 수 있다.

#### 1-2-4. 지속성: Durability

지속성(durability)란, 트랜잭션이 성공적으로 완료된 후 그 결과가 데이터베이스에 영구적으로 반영되어야 한다는 것을 의미한다. 즉, 트랜잭션이 commit 된 이후에는 시스템의 전원이 꺼지거나 다운되는 등의 장애가 발생하더라도 해당 트랜잭션에 의해 변경된 데이터는 손실되지 않고 보존되어야 한다는 원칙이다. 지속성을 보장하기 위해 데이터베이스 관리 시스템은 트랜잭션이 커밋되면 변경 내용을 HDD, SSD와 같은 비휘발성 저장소에 기록한다. 데이터의 손실을 방지하고 시스템 장애 이후에도 안정적으로 데이터를 복구할 수 있는 기반을 마련하기 위한 장치이다.

##### 1-2-4-1. Write-Ahead Logging

데이터베이스의 지속성을 강화하기 위한 기법이다. 데이터베이스의 변경 사항을 실제 데이터베이스에 기록하기 전에 로그 파일에 먼저 기록하여 데이터 무결성과 회복성을 향상시키기 위한 목적이다. 뿐만 아니라 다수의 I/O 작업을 병행할 수 있어 동시성을 개선하는 역할도 수행하며, PostgreSQL나 Oracle과 같은 모던 DBMS에서 널리 사용된다. 다음은 WAL의 작동 원리이다.

1. 로그 레코드 작성: 트랜잭션이 데이터베이스의 일부를 변경하려 할 때, 해당 변경 사항에 대한 로그 레코드가 로그 파일에 먼저 기록된다. 로그 레코드에는 변경 전/후 데이터와 트랜잭션 ID 등이 포함되며 이 로그는 디스크와 같은 비휘발성 저장소에 기록된다.
2. 데이터베이스 변경: 로그 레코드가 안전하게 저장된 후에 실제 데이터베이스 파일에 변경 사항을 적용한다.
3. 커밋 로그 기록: 트랜잭션이 성공적으로 완료되고 커밋될 경우, 해당 트랜잭션이 종료되었음을 나타내는 로드 레코드가 추가로 기록된다.
